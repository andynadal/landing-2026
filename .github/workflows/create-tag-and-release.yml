name: ðŸš€ Release on merge to main

on:
  pull_request:
    types: [closed]
    branches: [main]

permissions:
  contents: write
  pull-requests: read

concurrency:
  group: release-main
  cancel-in-progress: false

jobs:
  release:
    if: ${{ github.event.pull_request.merged == true }}
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository (full history + tags)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine release bump from PR label
        id: bump
        uses: actions/github-script@v7
        with:
          script: |
            const labels = context.payload.pull_request.labels.map(l => l.name);
            const releaseLabels = labels.filter(l =>
              l === "release:major" ||
              l === "release:minor" ||
              l === "release:patch"
            );

            if (releaseLabels.length !== 1) {
              core.setFailed(
                `Expected exactly one release label (release:patch | minor | major). Found: ${releaseLabels.join(", ") || "(none)"}`
              );
              return;
            }

            const bump = releaseLabels[0].split(":")[1];
            core.setOutput("bump", bump);

      - name: Compute next SemVer tag
        id: ver
        shell: bash
        run: |
          set -euo pipefail

          bump="${{ steps.bump.outputs.bump }}"

          git fetch --tags --force

          latest_tag="$(git tag -l 'v*' --sort=-v:refname | head -n 1 || true)"
          if [[ -z "$latest_tag" ]]; then
            latest_tag="v0.0.0"
          fi

          base="${latest_tag#v}"
          IFS='.' read -r major minor patch <<<"$base"

          case "$bump" in
            major)
              major=$((major+1)); minor=0; patch=0 ;;
            minor)
              minor=$((minor+1)); patch=0 ;;
            patch)
              patch=$((patch+1)) ;;
            *)
              echo "Invalid bump: $bump"
              exit 1 ;;
          esac

          next="${major}.${minor}.${patch}"
          tag="v${next}"

          echo "latest_tag=$latest_tag" >> "$GITHUB_OUTPUT"
          echo "version=$next" >> "$GITHUB_OUTPUT"
          echo "tag=$tag" >> "$GITHUB_OUTPUT"

      - name: Build release notes
        id: notes
        shell: bash
        run: |
          set -euo pipefail

          # Create temporary file for release notes to avoid shell injection
          notes_file=$(mktemp)
          trap 'rm -f "$notes_file"' EXIT

          # Get basic info (these are safe as they're from GitHub context)
          pr_number="${{ github.event.pull_request.number }}"
          from="${{ steps.ver.outputs.latest_tag }}"
          to="${{ github.sha }}"

          # Write PR title safely using printf to avoid any shell expansion
          printf "## %s (#%s)\n" "${{ github.event.pull_request.title }}" "$pr_number" > "$notes_file"

          # Write PR body safely using Python environment variable approach
          if [[ -n "$PR_BODY" ]]; then
            python3 -c "import os; body = os.environ.get('PR_BODY', ''); body_clean = ' '.join(body.split()) if body.strip() else '_No PR description provided._'; body_final = body_clean[:1000] + '...' if len(body_clean) > 1000 else body_clean; print(body_final)" >> "$notes_file"
          else
            echo "_No PR description provided._" >> "$notes_file"
          fi

          # Add commit history section
          if git rev-parse -q --verify "refs/tags/$from" >/dev/null; then
            range="$from..$to"
            header="## Changes since $from"
          else
            range="$to"
            header="## Changes"
          fi

          echo "" >> "$notes_file"
          echo "$header" >> "$notes_file"

          # Get commits and write them safely (git log output is safe)
          if git log --pretty=format:'- %s (%h)' "$range" -- >> "$notes_file" 2>/dev/null; then
            :  # Success
          else
            echo "- No commits detected." >> "$notes_file"
          fi

          # Write to GitHub output using proper delimiter
          {
            echo "notes<<NOTES_EOF"
            cat "$notes_file"
            echo ""
            echo "NOTES_EOF"
          } >> "$GITHUB_OUTPUT"
        env:
          PR_BODY: ${{ github.event.pull_request.body }}

      - name: Safety check â€” tag must not exist
        shell: bash
        run: |
          set -euo pipefail
          tag="${{ steps.ver.outputs.tag }}"
          if git rev-parse -q --verify "refs/tags/${tag}" >/dev/null; then
            echo "Tag already exists: ${tag}"
            exit 1
          fi

      - name: Create and push annotated tag
        shell: bash
        run: |
          set -euo pipefail
          tag="${{ steps.ver.outputs.tag }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "$tag" -m "Release $tag"
          git push origin "$tag"

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          tag="${{ steps.ver.outputs.tag }}"
          gh release create "$tag" \
            --title "$tag" \
            --notes "${{ steps.notes.outputs.notes }}"
